{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"teehistorian-py","text":"<p>High-performance Python bindings for parsing teehistorian files, written in Rust using PyO3.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fast: Written in Rust for maximum performance</li> <li>Pythonic: Clean Python API with type hints and context managers</li> <li>Memory Efficient: Zero-copy parsing where possible</li> <li>Type Safe: Strong typing for all chunk types</li> <li>Easy to Use: Simple iterator-based interface</li> <li>Full Read/Write Support: Parse existing files and create new ones</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import teehistorian_py as th\n\n# Parse a teehistorian file (modern way)\nwith th.open(\"demo.teehistorian\") as parser:\n    for chunk in parser:\n        if isinstance(chunk, th.Join):\n            print(f\"Player {chunk.client_id} joined\")\n        elif isinstance(chunk, th.Drop):\n            print(f\"Player {chunk.client_id} left: {chunk.reason}\")\n</code></pre> <p>Or with Python 3.10+ match statement:</p> <pre><code>import teehistorian_py as th\n\nfor chunk in th.parse(\"demo.teehistorian\"):\n    match chunk:\n        case th.Join(client_id=cid):\n            print(f\"Player {cid} joined\")\n        case th.Drop(client_id=cid, reason=reason):\n            print(f\"Player {cid} left: {reason}\")\n</code></pre>"},{"location":"#writing-files","title":"Writing Files","text":"<pre><code>import teehistorian_py as th\n\n# Create a new teehistorian file (modern way with context manager)\nwith th.create(server_name=\"My Server\") as writer:\n    writer.write(th.Join(0))\n    writer.write(th.PlayerName(0, \"Alice\"))\n    writer.write(th.PlayerNew(0, 100, 200))\n    writer.save(\"recording.teehistorian\")\n    # EOS chunk is automatically written when exiting context\n\n# Method chaining for fluent API\nwriter = (th.create()\n    .set_header(\"server_name\", \"My Server\")\n    .write(th.Join(0))\n    .write(th.PlayerName(0, \"Player\")))\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install teehistorian-py\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation Guide</li> <li>Quick Start</li> <li>Writing Guide</li> <li>API Reference</li> <li>Writer API</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Issue Tracker</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the AGPLv3 License - see the LICENSE file for details.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to teehistorian-py!</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork and clone the repository</li> <li>Install Rust and Python dependencies</li> <li>Set up the development environment:</li> </ol> <pre><code># Create virtual environment\npython -m venv .venv\nsource .venv/bin/activate\n\n# Install development dependencies\npip install maturin pytest pytest-cov black isort mypy\n\n# Build the extension\nmaturin develop\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run Python tests\npytest tests/ -v\n\n# Run with coverage\npytest tests/ --cov=teehistorian_py --cov-report=html\n</code></pre>"},{"location":"contributing/#code-quality","title":"Code Quality","text":"<pre><code># Format Rust code\ncargo fmt\n\n# Lint Rust code\ncargo clippy -- -D warnings\n\n# Format Python code\nblack .\nisort .\n\n# Type check Python code\nmypy .\n</code></pre>"},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Create a new branch for your feature</li> <li>Make your changes</li> <li>Add tests for new functionality</li> <li>Ensure all tests pass</li> <li>Run code formatters and linters</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<ul> <li>Write clear commit messages</li> <li>Include tests for new features</li> <li>Update documentation as needed</li> <li>Ensure CI passes</li> <li>Keep changes focused and atomic</li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Use the GitHub issue tracker to report bugs or suggest features.</p> <p>Include: - Clear description of the issue - Steps to reproduce (for bugs) - Expected vs actual behavior - Environment details (OS, Python version, etc.)</p>"},{"location":"api/chunks/","title":"Chunks API","text":"<p>All chunk types share common methods and follow a consistent interface.</p>"},{"location":"api/chunks/#common-methods","title":"Common Methods","text":"<p>All chunk types implement these methods:</p>"},{"location":"api/chunks/#chunk_type-str","title":"<code>chunk_type() -&gt; str</code>","text":"<p>Returns the chunk type as a string.</p>"},{"location":"api/chunks/#to_dict-dict","title":"<code>to_dict() -&gt; dict</code>","text":"<p>Converts the chunk to a dictionary for easier inspection.</p>"},{"location":"api/chunks/#__repr__-str","title":"<code>__repr__() -&gt; str</code>","text":"<p>Returns a string representation of the chunk.</p>"},{"location":"api/chunks/#__str__-str","title":"<code>__str__() -&gt; str</code>","text":"<p>Returns a human-readable string representation.</p>"},{"location":"api/chunks/#chunk-type-reference","title":"Chunk Type Reference","text":"<p>See Chunk Types for a complete list of all available chunk types and their attributes.</p>"},{"location":"api/chunks/#player-lifecycle-chunks","title":"Player Lifecycle Chunks","text":"<ul> <li><code>Join</code></li> <li><code>JoinVer6</code></li> <li><code>Drop</code></li> <li><code>PlayerReady</code></li> </ul>"},{"location":"api/chunks/#player-state-chunks","title":"Player State Chunks","text":"<ul> <li><code>PlayerNew</code></li> <li><code>PlayerOld</code></li> <li><code>PlayerTeam</code></li> <li><code>PlayerName</code></li> <li><code>PlayerDiff</code></li> </ul>"},{"location":"api/chunks/#input-chunks","title":"Input Chunks","text":"<ul> <li><code>InputNew</code></li> <li><code>InputDiff</code></li> </ul>"},{"location":"api/chunks/#communication-chunks","title":"Communication Chunks","text":"<ul> <li><code>NetMessage</code></li> <li><code>ConsoleCommand</code></li> </ul>"},{"location":"api/chunks/#authentication-version-chunks","title":"Authentication &amp; Version Chunks","text":"<ul> <li><code>AuthLogin</code></li> <li><code>DdnetVersion</code></li> </ul>"},{"location":"api/chunks/#server-event-chunks","title":"Server Event Chunks","text":"<ul> <li><code>TickSkip</code></li> <li><code>TeamLoadSuccess</code></li> <li><code>TeamLoadFailure</code></li> <li><code>AntiBot</code></li> </ul>"},{"location":"api/chunks/#special-chunks","title":"Special Chunks","text":"<ul> <li><code>Eos</code></li> <li><code>Unknown</code></li> <li><code>CustomChunk</code></li> <li><code>Generic</code></li> </ul>"},{"location":"api/errors/","title":"Errors API","text":""},{"location":"api/errors/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>TeehistorianError\n\u251c\u2500\u2500 ParseError\n\u251c\u2500\u2500 ValidationError\n\u2514\u2500\u2500 FileError\n</code></pre>"},{"location":"api/errors/#teehistorianerror","title":"TeehistorianError","text":"<p>Base exception for all teehistorian parsing errors.</p> <p>All other exceptions inherit from this class.</p> <p>Usage: <pre><code>try:\n    parser = th.Teehistorian(data)\nexcept th.TeehistorianError as e:\n    print(f\"Error: {e}\")\n</code></pre></p>"},{"location":"api/errors/#parseerror","title":"ParseError","text":"<p>Exception for parsing errors.</p> <p>Inherits from <code>TeehistorianError</code>.</p> <p>Raised when the parser encounters invalid data or cannot parse a chunk.</p> <p>Usage: <pre><code>try:\n    parser = th.Teehistorian(corrupted_data)\n    for chunk in parser:\n        pass\nexcept th.ParseError as e:\n    print(f\"Parse failed: {e}\")\n</code></pre></p>"},{"location":"api/errors/#validationerror","title":"ValidationError","text":"<p>Exception for validation errors.</p> <p>Inherits from <code>TeehistorianError</code>.</p> <p>Raised when input data fails validation checks (e.g., empty data, too short, invalid format).</p> <p>Usage: <pre><code>try:\n    parser = th.Teehistorian(b\"\")\nexcept th.ValidationError as e:\n    print(f\"Validation failed: {e}\")\n</code></pre></p>"},{"location":"api/errors/#fileerror","title":"FileError","text":"<p>Exception for file I/O errors.</p> <p>Inherits from <code>TeehistorianError</code>.</p> <p>Raised when there are issues reading or accessing the file.</p> <p>Usage: <pre><code>try:\n    with open(\"demo.teehistorian\", \"rb\") as f:\n        data = f.read()\n    parser = th.Teehistorian(data)\nexcept th.FileError as e:\n    print(f\"File error: {e}\")\n</code></pre></p>"},{"location":"api/errors/#error-handling-best-practices","title":"Error Handling Best Practices","text":"<ol> <li>Catch specific exceptions first: Handle more specific exceptions before the base exception</li> <li>Provide context: Include filename or other context in error messages</li> <li>Log errors appropriately: Use Python's logging module for production code</li> <li>Clean up resources: Use context managers for file handling</li> </ol> <p>See Error Handling Guide for more detailed information and examples.</p>"},{"location":"api/parser/","title":"Parser API","text":""},{"location":"api/parser/#teehistorian","title":"Teehistorian","text":"<p>The main parser class for teehistorian files.</p>"},{"location":"api/parser/#constructor","title":"Constructor","text":"<pre><code>Teehistorian(data: bytes) -&gt; Teehistorian\n</code></pre> <p>Creates a new teehistorian parser from raw bytes.</p> <p>Parameters: - <code>data</code> (bytes): Raw teehistorian file data</p> <p>Returns: - <code>Teehistorian</code>: A new parser instance</p> <p>Raises: - <code>ValidationError</code>: If the data is empty or too short - <code>ParseError</code>: If the file format is invalid</p> <p>Example: <pre><code>with open(\"demo.teehistorian\", \"rb\") as f:\n    data = f.read()\n\nparser = th.Teehistorian(data)\n</code></pre></p>"},{"location":"api/parser/#methods","title":"Methods","text":""},{"location":"api/parser/#__iter__","title":"<code>__iter__()</code>","text":"<p>Returns the parser itself as an iterator.</p>"},{"location":"api/parser/#__next__","title":"<code>__next__()</code>","text":"<p>Returns the next chunk from the parser.</p> <p>Returns: - Chunk object or <code>None</code> at EOF</p> <p>Raises: - <code>ParseError</code>: If chunk parsing fails</p>"},{"location":"api/parser/#header","title":"<code>header()</code>","text":"<p>Get the header data as bytes.</p> <p>Returns: - <code>bytes</code>: Header bytes</p> <p>Raises: - <code>ParseError</code>: If header parsing fails</p>"},{"location":"api/parser/#register_custom_uuiduuid_string-str","title":"<code>register_custom_uuid(uuid_string: str)</code>","text":"<p>Register a custom UUID handler.</p> <p>Parameters: - <code>uuid_string</code> (str): The UUID string to register</p> <p>Returns: - <code>None</code></p> <p>Raises: - <code>ValidationError</code>: If UUID format is invalid</p>"},{"location":"api/parser/#get_registered_uuids","title":"<code>get_registered_uuids()</code>","text":"<p>Get registered handler UUIDs.</p> <p>Returns: - <code>list[str]</code>: List of registered UUID strings</p>"},{"location":"api/parser/#properties","title":"Properties","text":""},{"location":"api/parser/#chunk_count","title":"<code>chunk_count</code>","text":"<p>Get the current chunk count.</p> <p>Returns: - <code>int</code>: Number of chunks processed</p>"},{"location":"api/parser/#teehistorianparser","title":"TeehistorianParser","text":"<p>Alias for <code>Teehistorian</code> provided for backward compatibility.</p> <pre><code>TeehistorianParser = Teehistorian\n</code></pre>"},{"location":"api/writer/","title":"Writer API","text":"<p>The <code>TeehistorianWriter</code> class provides a Pythonic interface for creating teehistorian files programmatically. It follows Python best practices with context manager support, method chaining, and a clean API.</p>"},{"location":"api/writer/#quick-start","title":"Quick Start","text":"<pre><code>import teehistorian_py as th\n\n# Basic usage with context manager (recommended)\nwith th.create() as writer:\n    writer.write(th.Join(0))\n    writer.write(th.PlayerName(0, \"Alice\"))\n    writer.write(th.PlayerNew(0, 100, 200))\n    writer.save(\"game.teehistorian\")\n    # EOS chunk is automatically written when exiting context\n</code></pre>"},{"location":"api/writer/#creating-a-writer","title":"Creating a Writer","text":""},{"location":"api/writer/#thcreateheaders-teehistorianwriter","title":"<code>th.create(**headers)</code> \u2192 <code>TeehistorianWriter</code>","text":"<p>Creates a new teehistorian writer instance.</p> <p>Parameters: - <code>**headers</code>: Optional header fields to set immediately</p> <p>Returns: A new <code>TeehistorianWriter</code> instance</p> <pre><code># Basic creation\nwriter = th.create()\n\n# With initial headers\nwriter = th.create(\n    server_name=\"My Server\",\n    comment=\"Generated by my script\",\n    map_name=\"dm1\"\n)\n</code></pre>"},{"location":"api/writer/#teehistorianwriter-class","title":"TeehistorianWriter Class","text":""},{"location":"api/writer/#context-manager-support","title":"Context Manager Support","text":"<p>The writer supports Python's context manager protocol and automatically writes an <code>Eos()</code> chunk when exiting the context:</p> <pre><code>with th.create() as writer:\n    writer.write(th.Join(0))\n    # EOS is automatically written here\n</code></pre>"},{"location":"api/writer/#method-chaining","title":"Method Chaining","text":"<p>All writer methods return <code>self</code>, enabling fluent method chaining:</p> <pre><code>writer = (th.create()\n    .set_header(\"server_name\", \"My Server\")\n    .write(th.Join(0))\n    .write(th.PlayerName(0, \"Player\")))\n</code></pre>"},{"location":"api/writer/#writing-chunks","title":"Writing Chunks","text":""},{"location":"api/writer/#writechunk-teehistorianwriter","title":"<code>write(chunk)</code> \u2192 <code>TeehistorianWriter</code>","text":"<p>Writes a single chunk to the teehistorian file.</p> <p>Parameters: - <code>chunk</code>: A chunk object (Join, Drop, PlayerNew, etc.)</p> <p>Returns: Self for method chaining</p> <pre><code>writer.write(th.Join(0))\nwriter.write(th.PlayerName(0, \"Alice\"))\nwriter.write(th.Drop(0, \"quit\"))\n</code></pre>"},{"location":"api/writer/#write_allchunks-teehistorianwriter","title":"<code>write_all(chunks)</code> \u2192 <code>TeehistorianWriter</code>","text":"<p>Writes multiple chunks at once.</p> <p>Parameters: - <code>chunks</code>: Iterable of chunk objects</p> <p>Returns: Self for method chaining</p> <pre><code>chunks = [\n    th.Join(0),\n    th.PlayerName(0, \"Alice\"),\n    th.PlayerNew(0, 100, 200),\n    th.Eos()\n]\nwriter.write_all(chunks)\n</code></pre>"},{"location":"api/writer/#header-management","title":"Header Management","text":""},{"location":"api/writer/#set_headerkey-value-teehistorianwriter","title":"<code>set_header(key, value)</code> \u2192 <code>TeehistorianWriter</code>","text":"<p>Sets a single header field.</p> <p>Parameters: - <code>key</code> (str): Header field name - <code>value</code> (str): Header field value</p> <p>Returns: Self for method chaining</p> <p>Note: Headers can only be modified before writing the first chunk.</p> <pre><code>writer.set_header(\"server_name\", \"My Custom Server\")\nwriter.set_header(\"comment\", \"Generated by Python script\")\n</code></pre>"},{"location":"api/writer/#update_headersheaders-teehistorianwriter","title":"<code>update_headers(headers)</code> \u2192 <code>TeehistorianWriter</code>","text":"<p>Updates multiple header fields at once.</p> <p>Parameters: - <code>headers</code> (dict): Dictionary of header field name-value pairs</p> <p>Returns: Self for method chaining</p> <pre><code>writer.update_headers({\n    \"server_name\": \"My Server\",\n    \"comment\": \"Automated recording\",\n    \"map_name\": \"ctf5\"\n})\n</code></pre>"},{"location":"api/writer/#saving-and-output","title":"Saving and Output","text":""},{"location":"api/writer/#savepath-none","title":"<code>save(path)</code> \u2192 <code>None</code>","text":"<p>Saves the teehistorian file to disk.</p> <p>Parameters: - <code>path</code> (str | Path): File path to save to</p> <pre><code>writer.save(\"recording.teehistorian\")\nwriter.save(Path(\"recordings\") / \"game1.teehistorian\")\n</code></pre>"},{"location":"api/writer/#getvalue-bytes","title":"<code>getvalue()</code> \u2192 <code>bytes</code>","text":"<p>Gets the complete teehistorian data as bytes.</p> <p>Returns: Complete teehistorian file as bytes</p> <pre><code>data = writer.getvalue()\nwith open(\"file.teehistorian\", \"wb\") as f:\n    f.write(data)\n</code></pre>"},{"location":"api/writer/#writetofile-none","title":"<code>writeto(file)</code> \u2192 <code>None</code>","text":"<p>Writes the teehistorian data to a file-like object.</p> <p>Parameters: - <code>file</code>: File-like object with a <code>write()</code> method</p> <pre><code>with open(\"output.teehistorian\", \"wb\") as f:\n    writer.writeto(f)\n\n# Or with BytesIO\nfrom io import BytesIO\nbuffer = BytesIO()\nwriter.writeto(buffer)\n</code></pre>"},{"location":"api/writer/#properties","title":"Properties","text":""},{"location":"api/writer/#size-int","title":"<code>size</code> \u2192 <code>int</code>","text":"<p>Gets the current size of the teehistorian data in bytes.</p> <pre><code>print(f\"Current file size: {writer.size} bytes\")\n</code></pre>"},{"location":"api/writer/#is_empty-bool","title":"<code>is_empty</code> \u2192 <code>bool</code>","text":"<p>Checks if any data has been written to the teehistorian.</p> <pre><code>if writer.is_empty:\n    print(\"No data written yet\")\n</code></pre>"},{"location":"api/writer/#utility-methods","title":"Utility Methods","text":""},{"location":"api/writer/#reset-none","title":"<code>reset()</code> \u2192 <code>None</code>","text":"<p>Resets the writer to its initial empty state, clearing all data and headers.</p> <pre><code>writer.write(th.Join(0))\nprint(writer.size)  # &gt; 0\n\nwriter.reset()\nprint(writer.size)  # 0\nprint(writer.is_empty)  # True\n</code></pre>"},{"location":"api/writer/#__repr__-str","title":"<code>__repr__()</code> \u2192 <code>str</code>","text":"<p>Returns a string representation of the writer showing its current state.</p> <pre><code>writer = th.create()\nprint(writer)  # TeehistorianWriter(size=0, status=empty)\n\nwriter.write(th.Join(0))\nprint(writer)  # TeehistorianWriter(size=42, status=active)\n</code></pre>"},{"location":"api/writer/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"api/writer/#recording-a-complete-game","title":"Recording a Complete Game","text":"<pre><code>with th.create(server_name=\"My Server\", map_name=\"dm1\") as writer:\n    # Players join\n    writer.write(th.Join(0))\n    writer.write(th.Join(1))\n\n    # Set player names\n    writer.write(th.PlayerName(0, \"Alice\"))\n    writer.write(th.PlayerName(1, \"Bob\"))\n\n    # Players spawn\n    writer.write(th.PlayerNew(0, 100, 200))\n    writer.write(th.PlayerNew(1, 200, 100))\n\n    # Game events\n    writer.write(th.NetMessage(0, \"Hello everyone!\"))\n    writer.write(th.TickSkip(30))  # 30 ticks passed\n\n    # Players leave\n    writer.write(th.PlayerOld(1))\n    writer.write(th.Drop(1, \"timeout\"))\n\n    # Save the recording\n    writer.save(\"game_recording.teehistorian\")\n</code></pre>"},{"location":"api/writer/#batch-processing","title":"Batch Processing","text":"<pre><code>def create_recording(events, filename):\n    \"\"\"Create a teehistorian from a list of events.\"\"\"\n    with th.create() as writer:\n        writer.set_header(\"comment\", f\"Generated from {len(events)} events\")\n        writer.write_all(events)\n        writer.save(filename)\n\n# Usage\nevents = [\n    th.Join(0),\n    th.PlayerName(0, \"Player\"),\n    th.PlayerNew(0, 0, 0),\n]\ncreate_recording(events, \"batch_recording.teehistorian\")\n</code></pre>"},{"location":"api/writer/#streaming-to-network","title":"Streaming to Network","text":"<pre><code>import socket\n\ndef stream_teehistorian(writer, host, port):\n    \"\"\"Stream teehistorian data over network.\"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((host, port))\n        data = writer.getvalue()\n        sock.sendall(data)\n\n# Usage\nwriter = th.create()\nwriter.write(th.Join(0))\nstream_teehistorian(writer, \"localhost\", 8080)\n</code></pre>"},{"location":"api/writer/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    with th.create() as writer:\n        writer.set_header(\"server_name\", \"My Server\")\n        writer.write(th.Join(0))\n        # Trying to modify header after writing chunks raises an error\n        writer.set_header(\"comment\", \"This will fail\")  # ValueError\nexcept ValueError as e:\n    print(f\"Header modification error: {e}\")\n\ntry:\n    writer = th.create()\n    writer.write(th.Join(0))\n    # Using a closed writer\n    writer._closed = True\n    writer.write(th.Drop(0, \"quit\"))  # ValueError\nexcept ValueError as e:\n    print(f\"Closed writer error: {e}\")\n</code></pre>"},{"location":"api/writer/#thread-safety","title":"Thread Safety","text":"<p>The <code>TeehistorianWriter</code> is not thread-safe. If you need to write from multiple threads, use appropriate synchronization:</p> <pre><code>import threading\n\nwriter = th.create()\nlock = threading.Lock()\n\ndef write_chunk(chunk):\n    with lock:\n        writer.write(chunk)\n\n# Use write_chunk from multiple threads\n</code></pre>"},{"location":"api/writer/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use context managers - They ensure proper cleanup and automatic EOS writing</li> <li>Batch writes - Use <code>write_all()</code> for better performance when writing many chunks</li> <li>Pre-allocate headers - Set all headers during creation or before first write</li> <li>Stream large files - Use <code>writeto()</code> with file objects instead of keeping everything in memory</li> </ol> <pre><code># Good: Use context manager and batch writes\nwith th.create(server_name=\"My Server\") as writer:\n    chunks = [th.Join(i) for i in range(100)]\n    writer.write_all(chunks)\n\n    # Stream directly to file for large recordings\n    with open(\"large_recording.teehistorian\", \"wb\") as f:\n        writer.writeto(f)\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>pip</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The easiest way to install teehistorian-py is from PyPI:</p> <pre><code>pip install teehistorian-py\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>If you want to install from source or contribute to development:</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust toolchain (1.70+)</li> <li>Python 3.8+</li> <li>pip</li> </ul>"},{"location":"getting-started/installation/#steps","title":"Steps","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/KoG-teeworlds/teehistorian-py.git\ncd teehistorian-py\n</code></pre></p> </li> <li> <p>Create a virtual environment (recommended): <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>Install maturin: <pre><code>pip install maturin\n</code></pre></p> </li> <li> <p>Build and install: <pre><code>maturin develop --release\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import teehistorian_py as th\nprint(th.__version__)\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#rust-not-found","title":"Rust Not Found","text":"<p>If you get an error about Rust not being found, install it from rustup.rs.</p>"},{"location":"getting-started/installation/#build-errors","title":"Build Errors","text":"<p>Make sure you have the latest version of pip and maturin: <pre><code>pip install --upgrade pip maturin\n</code></pre></p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":""},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example to get you started with teehistorian-py:</p> <pre><code>import teehistorian_py as th\n\n# Parse from file path with context manager (recommended)\nwith th.open(\"demo.teehistorian\") as parser:\n    for chunk in parser:\n        print(chunk)\n</code></pre> <p>Without context manager:</p> <pre><code>import teehistorian_py as th\n\n# Parse from file path\nparser = th.parse(\"demo.teehistorian\")\n\n# Iterate over chunks\nfor chunk in parser:\n    print(chunk)\n</code></pre> <p>Or using <code>pathlib</code>:</p> <pre><code>from pathlib import Path\nimport teehistorian_py as th\n\n# Works with Path objects too\nparser = th.parse(Path(\"demo.teehistorian\"))\n\nfor chunk in parser:\n    print(chunk)\n</code></pre> <p>If you already have bytes in memory:</p> <pre><code>import teehistorian_py as th\n\n# Parse from bytes directly\ndata = Path(\"demo.teehistorian\").read_bytes()\nparser = th.Teehistorian(data)\n\nfor chunk in parser:\n    print(chunk)\n</code></pre>"},{"location":"getting-started/quickstart/#filtering-specific-events","title":"Filtering Specific Events","text":"<p>You can filter for specific chunk types using <code>isinstance</code>:</p> <pre><code>import teehistorian_py as th\n\n# Track player joins and drops\nfor chunk in th.parse(\"demo.teehistorian\"):\n    if isinstance(chunk, th.Join):\n        print(f\"Player {chunk.client_id} joined the server\")\n    elif isinstance(chunk, th.Drop):\n        print(f\"Player {chunk.client_id} left: {chunk.reason}\")\n</code></pre> <p>Or use Python 3.10+ match statement for cleaner code:</p> <pre><code>import teehistorian_py as th\n\nfor chunk in th.parse(\"demo.teehistorian\"):\n    match chunk:\n        case th.Join(client_id=cid):\n            print(f\"Player {cid} joined the server\")\n        case th.Drop(client_id=cid, reason=reason):\n            print(f\"Player {cid} left: {reason}\")\n        case th.PlayerNew(client_id=cid, x=x, y=y):\n            print(f\"Player {cid} spawned at ({x}, {y})\")\n</code></pre>"},{"location":"getting-started/quickstart/#accessing-chunk-data","title":"Accessing Chunk Data","text":"<p>Each chunk type has specific attributes:</p> <pre><code>import teehistorian_py as th\n\nfor chunk in th.parse(\"demo.teehistorian\"):\n    if isinstance(chunk, th.PlayerNew):\n        print(f\"Player {chunk.client_id} spawned at ({chunk.x}, {chunk.y})\")\n    elif isinstance(chunk, th.ConsoleCommand):\n        print(f\"Player {chunk.client_id} executed: {chunk.command} {chunk.args}\")\n</code></pre> <p>All chunks support conversion to dictionaries:</p> <pre><code>import teehistorian_py as th\n\nfor chunk in th.parse(\"demo.teehistorian\"):\n    # Convert to dict for inspection or JSON serialization\n    chunk_dict = chunk.to_dict()\n    print(chunk_dict)\n</code></pre>"},{"location":"getting-started/quickstart/#error-handling","title":"Error Handling","text":"<p>Handle parsing errors gracefully:</p> <pre><code>import teehistorian_py as th\n\ntry:\n    for chunk in th.parse(\"demo.teehistorian\"):\n        # Process chunks\n        pass\n\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\nexcept th.ValidationError as e:\n    print(f\"Invalid file format: {e}\")\nexcept th.ParseError as e:\n    print(f\"Parse error: {e}\")\nexcept th.TeehistorianError as e:\n    print(f\"General error: {e}\")\n</code></pre> <p>Or handle multiple files with error recovery:</p> <pre><code>import teehistorian_py as th\nfrom pathlib import Path\n\ndef parse_all_files(directory: Path):\n    \"\"\"Parse all teehistorian files in a directory.\"\"\"\n    for path in directory.glob(\"*.teehistorian\"):\n        try:\n            parser = th.parse(path)\n            yield from parser\n        except th.TeehistorianError as e:\n            print(f\"Error parsing {path}: {e}\")\n            continue\n\n# Usage\nfor chunk in parse_all_files(Path(\"replays\")):\n    print(chunk)\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about all chunk types</li> <li>Explore error handling</li> <li>Check the API reference</li> </ul>"},{"location":"getting-started/writing/","title":"Writing Teehistorian Files","text":"<p>This guide will show you how to create teehistorian files from scratch using the <code>TeehistorianWriter</code> API.</p>"},{"location":"getting-started/writing/#overview","title":"Overview","text":"<p>The <code>TeehistorianWriter</code> provides a Pythonic interface for creating teehistorian files programmatically. It follows Python best practices with:</p> <ul> <li>Context manager support - Automatic cleanup and EOS writing</li> <li>Method chaining - Fluent API for readable code</li> <li>Type safety - Strong typing for all operations</li> <li>Flexible output - Save to file, get as bytes, or write to file-like objects</li> </ul>"},{"location":"getting-started/writing/#your-first-teehistorian-file","title":"Your First Teehistorian File","text":"<p>Let's create a simple teehistorian file with one player joining, saying something, and leaving:</p> <pre><code>import teehistorian_py as th\n\n# Create a new teehistorian file\nwith th.create() as writer:\n    # Set some metadata\n    writer.set_header(\"server_name\", \"My Test Server\")\n    writer.set_header(\"comment\", \"First recording\")\n\n    # Player joins\n    writer.write(th.Join(0))\n\n    # Set player name\n    writer.write(th.PlayerName(0, \"TestPlayer\"))\n\n    # Player spawns at coordinates (100, 200)\n    writer.write(th.PlayerNew(0, 100, 200))\n\n    # Player sends a message\n    writer.write(th.NetMessage(0, \"Hello, world!\"))\n\n    # Some time passes (30 ticks)\n    writer.write(th.TickSkip(30))\n\n    # Player leaves\n    writer.write(th.PlayerOld(0))\n    writer.write(th.Drop(0, \"quit\"))\n\n    # Save the file\n    writer.save(\"my_first_recording.teehistorian\")\n    # EOS chunk is automatically written when exiting the context\n</code></pre> <p>That's it! You've created your first teehistorian file.</p>"},{"location":"getting-started/writing/#understanding-headers","title":"Understanding Headers","text":"<p>Headers contain metadata about the recording. Common headers include:</p> <pre><code>with th.create() as writer:\n    # Server information\n    writer.set_header(\"server_name\", \"KoG Server\")\n    writer.set_header(\"server_version\", \"DDNet 17.4.2\")\n\n    # Recording information\n    writer.set_header(\"comment\", \"Epic race on Sunny Side Up\")\n    writer.set_header(\"map_name\", \"Sunny Side Up\")\n\n    # Timestamps (automatically set, but can be overridden)\n    writer.set_header(\"start_time\", \"2024-01-15T10:30:00Z\")\n\n    # Custom fields\n    writer.set_header(\"recorder\", \"My Bot v1.0\")\n    writer.set_header(\"game_type\", \"DDRace\")\n</code></pre> <p>You can also set headers during creation:</p> <pre><code>writer = th.create(\n    server_name=\"My Server\",\n    comment=\"Automated recording\",\n    map_name=\"dm1\"\n)\n</code></pre>"},{"location":"getting-started/writing/#chunk-types-and-usage","title":"Chunk Types and Usage","text":""},{"location":"getting-started/writing/#player-lifecycle","title":"Player Lifecycle","text":"<p>Track players joining and leaving:</p> <pre><code># Player joins\nwriter.write(th.Join(client_id))\nwriter.write(th.JoinVer6(client_id))  # For version 6 protocol\n\n# Player becomes ready\nwriter.write(th.PlayerReady(client_id))\n\n# Player leaves\nwriter.write(th.PlayerOld(client_id))\nwriter.write(th.Drop(client_id, reason))\n</code></pre>"},{"location":"getting-started/writing/#player-information","title":"Player Information","text":"<p>Set and update player information:</p> <pre><code># Set player name\nwriter.write(th.PlayerName(client_id, \"PlayerName\"))\n\n# Set player team\nwriter.write(th.PlayerTeam(client_id, team_id))\n\n# Player spawns at position\nwriter.write(th.PlayerNew(client_id, x, y))\n\n# Player moves (relative movement)\nwriter.write(th.PlayerDiff(client_id, dx, dy))\n</code></pre>"},{"location":"getting-started/writing/#communication","title":"Communication","text":"<p>Record chat messages and commands:</p> <pre><code># Chat message\nwriter.write(th.NetMessage(client_id, \"Hello everyone!\"))\n\n# Console command\nwriter.write(th.ConsoleCommand(client_id, flags, \"say\", \"message\"))\n\n# Authentication\nwriter.write(th.AuthLogin(client_id, level, \"admin_name\"))\n</code></pre>"},{"location":"getting-started/writing/#server-events","title":"Server Events","text":"<p>Record server-side events:</p> <pre><code># Time skip (when server is idle)\nwriter.write(th.TickSkip(ticks))\n\n# Team events (for team-based games)\nwriter.write(th.TeamLoadSuccess(team_id, save_data))\nwriter.write(th.TeamLoadFailure(team_id))\n\n# Anti-cheat data\nwriter.write(th.AntiBot(\"detection_data\"))\n\n# Version information\nwriter.write(th.DdnetVersion(client_id, connection_id, version, version_str))\n\n# End of stream (automatically added by context manager)\nwriter.write(th.Eos())\n</code></pre>"},{"location":"getting-started/writing/#realistic-example-recording-a-race","title":"Realistic Example: Recording a Race","text":"<p>Here's a more complete example of recording a DDRace game:</p> <pre><code>import teehistorian_py as th\nfrom datetime import datetime\n\ndef record_race():\n    \"\"\"Record a typical DDRace session.\"\"\"\n\n    with th.create() as writer:\n        # Set up recording metadata\n        writer.update_headers({\n            \"server_name\": \"KoG Gores\",\n            \"map_name\": \"Sunny Side Up\", \n            \"game_type\": \"DDRace\",\n            \"comment\": \"Race recording with 3 players\",\n            \"start_time\": datetime.utcnow().isoformat() + \"Z\"\n        })\n\n        # Three players join\n        for player_id in range(3):\n            writer.write(th.Join(player_id))\n\n        # Set player names\n        player_names = [\"Alice\", \"Bob\", \"Charlie\"]\n        for player_id, name in enumerate(player_names):\n            writer.write(th.PlayerName(player_id, name))\n\n        # Players become ready\n        for player_id in range(3):\n            writer.write(th.PlayerReady(player_id))\n\n        # Players spawn at start position\n        start_positions = [(100, 200), (110, 200), (120, 200)]\n        for player_id, (x, y) in enumerate(start_positions):\n            writer.write(th.PlayerNew(player_id, x, y))\n\n        # Race begins - players move\n        writer.write(th.NetMessage(0, \"Ready?\"))\n        writer.write(th.TickSkip(60))  # 1 second pause\n        writer.write(th.NetMessage(0, \"GO!\"))\n\n        # Simulate some movement and events\n        movements = [\n            (0, 5, -2),   # Alice moves right and up\n            (1, 3, 1),    # Bob moves right and down  \n            (2, 4, 0),    # Charlie moves right\n        ]\n\n        for player_id, dx, dy in movements:\n            writer.write(th.PlayerDiff(player_id, dx, dy))\n\n        # More race events\n        writer.write(th.TickSkip(300))  # 5 seconds of racing\n        writer.write(th.NetMessage(1, \"Nice jump!\"))\n\n        writer.write(th.TickSkip(600))  # 10 more seconds\n        writer.write(th.NetMessage(0, \"Almost there!\"))\n\n        # Alice finishes first\n        writer.write(th.NetMessage(0, \"Yes! Personal best!\"))\n        writer.write(th.PlayerOld(0))\n        writer.write(th.Drop(0, \"finished\"))\n\n        # Others finish\n        writer.write(th.TickSkip(180))  # 3 seconds later\n        writer.write(th.PlayerOld(1))\n        writer.write(th.Drop(1, \"finished\"))\n\n        writer.write(th.TickSkip(300))  # 5 seconds later\n        writer.write(th.PlayerOld(2))\n        writer.write(th.Drop(2, \"timeout\"))\n\n        # Save the recording\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        filename = f\"race_recording_{timestamp}.teehistorian\"\n        writer.save(filename)\n\n        print(f\"Race recording saved: {filename}\")\n        print(f\"File size: {writer.size} bytes\")\n\n# Run the recording\nrecord_race()\n</code></pre>"},{"location":"getting-started/writing/#working-with-file-like-objects","title":"Working with File-like Objects","text":"<p>You don't always need to save to disk. You can work with any file-like object:</p> <pre><code>from io import BytesIO\nimport gzip\n\n# Write to memory buffer\nbuffer = BytesIO()\nwith th.create() as writer:\n    writer.write(th.Join(0))\n    writer.writeto(buffer)\n\n# Get the data\ndata = buffer.getvalue()\nprint(f\"Teehistorian size: {len(data)} bytes\")\n\n# Write compressed file\nwith gzip.open(\"compressed.teehistorian.gz\", \"wb\") as f:\n    with th.create() as writer:\n        writer.write(th.Join(0))\n        writer.write(th.PlayerName(0, \"Player\"))\n        writer.writeto(f)\n</code></pre>"},{"location":"getting-started/writing/#batch-operations","title":"Batch Operations","text":"<p>For better performance when writing many chunks:</p> <pre><code># Create many chunks\nchunks = []\nfor i in range(100):\n    chunks.extend([\n        th.Join(i),\n        th.PlayerName(i, f\"Player{i}\"),\n        th.PlayerNew(i, i * 10, 200),\n    ])\n\n# Write them all at once\nwith th.create() as writer:\n    writer.write_all(chunks)\n    writer.save(\"batch_recording.teehistorian\")\n</code></pre>"},{"location":"getting-started/writing/#method-chaining","title":"Method Chaining","text":"<p>The writer supports fluent method chaining for readable code:</p> <pre><code># All methods return self, so you can chain them\nrecording = (th.create()\n    .set_header(\"server_name\", \"Chain Server\")\n    .write(th.Join(0))\n    .write(th.PlayerName(0, \"ChainPlayer\"))\n    .write(th.PlayerNew(0, 100, 200)))\n\n# Save when done\nrecording.save(\"chained_recording.teehistorian\")\n</code></pre>"},{"location":"getting-started/writing/#error-handling","title":"Error Handling","text":"<p>Handle common errors gracefully:</p> <pre><code>try:\n    with th.create() as writer:\n        writer.set_header(\"server_name\", \"My Server\")\n        writer.write(th.Join(0))\n\n        # This will raise an error - can't modify headers after writing\n        writer.set_header(\"comment\", \"Too late!\")\n\nexcept ValueError as e:\n    print(f\"Header error: {e}\")\n\ntry:\n    writer = th.create()\n    writer.write(th.Join(0))\n\n    # Manually closing and trying to write\n    writer._closed = True\n    writer.write(th.Drop(0, \"quit\"))  # Will raise ValueError\n\nexcept ValueError as e:\n    print(f\"Closed writer error: {e}\")\n</code></pre>"},{"location":"getting-started/writing/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/writing/#1-always-use-context-managers","title":"1. Always Use Context Managers","text":"<pre><code># Good - automatic cleanup and EOS\nwith th.create() as writer:\n    writer.write(th.Join(0))\n\n# Avoid - manual management\nwriter = th.create()\nwriter.write(th.Join(0))\nwriter.write(th.Eos())  # Must remember to add EOS\n</code></pre>"},{"location":"getting-started/writing/#2-set-headers-early","title":"2. Set Headers Early","text":"<pre><code># Good - headers set before any chunks\nwith th.create(server_name=\"My Server\") as writer:\n    writer.write(th.Join(0))\n\n# Avoid - headers after chunks (will raise error)\nwith th.create() as writer:\n    writer.write(th.Join(0))\n    writer.set_header(\"server_name\", \"My Server\")  # Error!\n</code></pre>"},{"location":"getting-started/writing/#3-use-batch-operations-for-performance","title":"3. Use Batch Operations for Performance","text":"<pre><code># Good - batch writing\nchunks = [th.Join(i) for i in range(100)]\nwriter.write_all(chunks)\n\n# Less efficient - individual writes\nfor i in range(100):\n    writer.write(th.Join(i))\n</code></pre>"},{"location":"getting-started/writing/#4-handle-large-files-efficiently","title":"4. Handle Large Files Efficiently","text":"<pre><code># Good - stream directly to file\nwith open(\"large_recording.teehistorian\", \"wb\") as f:\n    with th.create() as writer:\n        # ... write many chunks ...\n        writer.writeto(f)  # Stream directly\n\n# Avoid - loading everything into memory first\nwith th.create() as writer:\n    # ... write many chunks ...\n    data = writer.getvalue()  # All in memory\n    with open(\"large_recording.teehistorian\", \"wb\") as f:\n        f.write(data)\n</code></pre>"},{"location":"getting-started/writing/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the Writer API Reference for detailed method documentation</li> <li>Learn about all available Chunk Types</li> <li>See the Parser Guide for reading teehistorian files</li> <li>Browse the examples for more complex use cases</li> </ul>"},{"location":"getting-started/writing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/writing/#cannot-modify-header-after-writing-has-started","title":"\"Cannot modify header after writing has started\"","text":"<p>Headers can only be set before writing the first chunk:</p> <pre><code># Fix: Set headers before any writes\nwith th.create() as writer:\n    writer.set_header(\"server_name\", \"My Server\")  # Must come first\n    writer.write(th.Join(0))\n</code></pre>"},{"location":"getting-started/writing/#cannot-write-to-closed-writer","title":"\"Cannot write to closed writer\"","text":"<p>This happens when trying to write after the context manager has exited:</p> <pre><code># Fix: Keep operations inside the context\nwith th.create() as writer:\n    writer.write(th.Join(0))\n    writer.save(\"file.teehistorian\")  # Save inside context\n</code></pre>"},{"location":"getting-started/writing/#large-file-performance-issues","title":"Large File Performance Issues","text":"<p>For very large recordings:</p> <pre><code># Fix: Use streaming and batch operations\nwith open(\"huge_recording.teehistorian\", \"wb\") as f:\n    with th.create() as writer:\n        # Write in batches\n        batch_size = 1000\n        for i in range(0, total_chunks, batch_size):\n            batch = chunks[i:i+batch_size]\n            writer.write_all(batch)\n        writer.writeto(f)  # Stream to file\n</code></pre>"},{"location":"guide/basic-usage/","title":"Basic Usage","text":""},{"location":"guide/basic-usage/#creating-a-parser","title":"Creating a Parser","text":"<p>The recommended way to parse teehistorian files is using the <code>open()</code> function with a context manager:</p> <pre><code>import teehistorian_py as th\n\n# Recommended: use context manager\nwith th.open(\"demo.teehistorian\") as parser:\n    for chunk in parser:\n        print(chunk)\n</code></pre> <p>Alternative methods:</p> <pre><code>import teehistorian_py as th\n\n# Method 1: Using parse()\nparser = th.parse(\"demo.teehistorian\")\n\n# Method 2: From bytes directly\nfrom pathlib import Path\ndata = Path(\"demo.teehistorian\").read_bytes()\nparser = th.Teehistorian(data)\n</code></pre>"},{"location":"guide/basic-usage/#iterating-over-chunks","title":"Iterating Over Chunks","text":"<p>The parser implements the iterator protocol, allowing you to loop over all chunks:</p> <pre><code>for chunk in parser:\n    print(f\"Chunk type: {chunk.chunk_type()}\")\n    print(f\"Chunk data: {chunk}\")\n</code></pre>"},{"location":"guide/basic-usage/#using-teehistorianparser-alias","title":"Using TeehistorianParser Alias","text":"<p>For backward compatibility, you can also use <code>TeehistorianParser</code>:</p> <pre><code># These are equivalent\nparser1 = th.Teehistorian(data)\nparser2 = th.TeehistorianParser(data)\n</code></pre>"},{"location":"guide/basic-usage/#converting-chunks-to-dictionaries","title":"Converting Chunks to Dictionaries","text":"<p>All chunks can be converted to dictionaries for easier inspection:</p> <pre><code>for chunk in parser:\n    chunk_dict = chunk.to_dict()\n    print(chunk_dict)\n</code></pre>"},{"location":"guide/basic-usage/#getting-parser-statistics","title":"Getting Parser Statistics","text":"<p>You can access the chunk count during iteration:</p> <pre><code>parser = th.Teehistorian(data)\n\nfor chunk in parser:\n    # Process chunk\n    pass\n\nprint(f\"Processed {parser.chunk_count} chunks\")\n</code></pre>"},{"location":"guide/chunk-types/","title":"Chunk Types","text":""},{"location":"guide/chunk-types/#player-lifecycle","title":"Player Lifecycle","text":""},{"location":"guide/chunk-types/#join","title":"Join","text":"<p>Player joins the server.</p> <pre><code>chunk.client_id  # int\n</code></pre>"},{"location":"guide/chunk-types/#joinver6","title":"JoinVer6","text":"<p>Player joins with version 6 protocol.</p> <pre><code>chunk.client_id  # int\n</code></pre>"},{"location":"guide/chunk-types/#drop","title":"Drop","text":"<p>Player disconnects from the server.</p> <pre><code>chunk.client_id  # int\nchunk.reason     # str\n</code></pre>"},{"location":"guide/chunk-types/#playerready","title":"PlayerReady","text":"<p>Player becomes ready to play.</p> <pre><code>chunk.client_id  # int\n</code></pre>"},{"location":"guide/chunk-types/#player-state","title":"Player State","text":""},{"location":"guide/chunk-types/#playernew","title":"PlayerNew","text":"<p>New player spawn position.</p> <pre><code>chunk.client_id  # int\nchunk.x          # int\nchunk.y          # int\n</code></pre>"},{"location":"guide/chunk-types/#playerold","title":"PlayerOld","text":"<p>Player leaves the game (but not server).</p> <pre><code>chunk.client_id  # int\n</code></pre>"},{"location":"guide/chunk-types/#playerteam","title":"PlayerTeam","text":"<p>Player changes team.</p> <pre><code>chunk.client_id  # int\nchunk.team       # int\n</code></pre>"},{"location":"guide/chunk-types/#playername","title":"PlayerName","text":"<p>Player changes name.</p> <pre><code>chunk.client_id  # int\nchunk.name       # str\n</code></pre>"},{"location":"guide/chunk-types/#playerdiff","title":"PlayerDiff","text":"<p>Player position difference/update.</p> <pre><code>chunk.client_id  # int\nchunk.dx         # int\nchunk.dy         # int\n</code></pre>"},{"location":"guide/chunk-types/#input-events","title":"Input Events","text":""},{"location":"guide/chunk-types/#inputnew","title":"InputNew","text":"<p>New player input state.</p> <pre><code>chunk.client_id  # int\nchunk.input      # str\n</code></pre>"},{"location":"guide/chunk-types/#inputdiff","title":"InputDiff","text":"<p>Player input difference from previous state.</p> <pre><code>chunk.client_id  # int\nchunk.input      # List[int]\n</code></pre>"},{"location":"guide/chunk-types/#communication","title":"Communication","text":""},{"location":"guide/chunk-types/#netmessage","title":"NetMessage","text":"<p>Network message from/to player.</p> <pre><code>chunk.client_id  # int\nchunk.message    # str\n</code></pre>"},{"location":"guide/chunk-types/#consolecommand","title":"ConsoleCommand","text":"<p>Console command executed by player.</p> <pre><code>chunk.client_id  # int\nchunk.flags      # int\nchunk.command    # str\nchunk.args       # str\n</code></pre>"},{"location":"guide/chunk-types/#authentication-version","title":"Authentication &amp; Version","text":""},{"location":"guide/chunk-types/#authlogin","title":"AuthLogin","text":"<p>Player authentication/login.</p> <pre><code>chunk.client_id  # int\nchunk.level      # int\nchunk.name       # str\n</code></pre>"},{"location":"guide/chunk-types/#ddnetversion","title":"DdnetVersion","text":"<p>DDNet client version information.</p> <pre><code>chunk.client_id     # int\nchunk.connection_id # str\nchunk.version       # int\nchunk.version_str   # bytes\n</code></pre>"},{"location":"guide/chunk-types/#server-events","title":"Server Events","text":""},{"location":"guide/chunk-types/#tickskip","title":"TickSkip","text":"<p>Server tick skip.</p> <pre><code>chunk.dt  # int\n</code></pre>"},{"location":"guide/chunk-types/#teamloadsuccess","title":"TeamLoadSuccess","text":"<p>Team save loaded successfully.</p> <pre><code>chunk.team  # int\nchunk.save  # str\n</code></pre>"},{"location":"guide/chunk-types/#teamloadfailure","title":"TeamLoadFailure","text":"<p>Team save load failed.</p> <pre><code>chunk.team  # int\n</code></pre>"},{"location":"guide/chunk-types/#antibot","title":"AntiBot","text":"<p>Anti-bot system event.</p> <pre><code>chunk.data  # str\n</code></pre>"},{"location":"guide/chunk-types/#special-chunks","title":"Special Chunks","text":""},{"location":"guide/chunk-types/#eos","title":"Eos","text":"<p>End of stream marker.</p> <p>No attributes.</p>"},{"location":"guide/chunk-types/#unknown","title":"Unknown","text":"<p>Unknown chunk with UUID.</p> <pre><code>chunk.uuid  # str\nchunk.data  # bytes\n</code></pre>"},{"location":"guide/chunk-types/#customchunk","title":"CustomChunk","text":"<p>Custom chunk with registered handler.</p> <pre><code>chunk.uuid          # str\nchunk.data          # bytes\nchunk.handler_name  # str\n</code></pre>"},{"location":"guide/chunk-types/#generic","title":"Generic","text":"<p>Generic/fallback chunk type.</p> <pre><code>chunk.data  # str\n</code></pre>"},{"location":"guide/error-handling/","title":"Error Handling","text":""},{"location":"guide/error-handling/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>teehistorian-py provides a hierarchy of exceptions for different error scenarios:</p> <pre><code>TeehistorianError (base exception)\n\u251c\u2500\u2500 ParseError (parsing errors)\n\u251c\u2500\u2500 ValidationError (validation errors)\n\u2514\u2500\u2500 FileError (I/O errors)\n</code></pre>"},{"location":"guide/error-handling/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>import teehistorian_py as th\n\ntry:\n    with open(\"demo.teehistorian\", \"rb\") as f:\n        data = f.read()\n\n    parser = th.Teehistorian(data)\n\n    for chunk in parser:\n        # Process chunks\n        pass\n\nexcept th.TeehistorianError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"guide/error-handling/#handling-specific-errors","title":"Handling Specific Errors","text":""},{"location":"guide/error-handling/#validationerror","title":"ValidationError","text":"<p>Raised when the input data fails validation:</p> <pre><code>try:\n    parser = th.Teehistorian(b\"\")  # Empty data\nexcept th.ValidationError as e:\n    print(f\"Invalid data: {e}\")\n    # Output: Invalid data: Validation failed: Cannot parse empty data\n</code></pre>"},{"location":"guide/error-handling/#parseerror","title":"ParseError","text":"<p>Raised when parsing fails:</p> <pre><code>try:\n    parser = th.Teehistorian(invalid_data)\n    for chunk in parser:\n        pass\nexcept th.ParseError as e:\n    print(f\"Parse failed: {e}\")\n</code></pre>"},{"location":"guide/error-handling/#fileerror","title":"FileError","text":"<p>Raised for I/O related errors:</p> <pre><code>try:\n    with open(\"demo.teehistorian\", \"rb\") as f:\n        data = f.read()\n    parser = th.Teehistorian(data)\nexcept th.FileError as e:\n    print(f\"File error: {e}\")\nexcept FileNotFoundError:\n    print(\"File not found\")\n</code></pre>"},{"location":"guide/error-handling/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>import teehistorian_py as th\n\ndef parse_teehistorian_file(filename):\n    try:\n        # Read file\n        with open(filename, \"rb\") as f:\n            data = f.read()\n\n        # Create parser\n        parser = th.Teehistorian(data)\n\n        # Process chunks\n        chunks = []\n        for chunk in parser:\n            chunks.append(chunk)\n\n        return chunks\n\n    except FileNotFoundError:\n        print(f\"File not found: {filename}\")\n        return None\n\n    except th.ValidationError as e:\n        print(f\"Invalid teehistorian file: {e}\")\n        return None\n\n    except th.ParseError as e:\n        print(f\"Failed to parse file: {e}\")\n        return None\n\n    except th.FileError as e:\n        print(f\"I/O error: {e}\")\n        return None\n\n    except th.TeehistorianError as e:\n        print(f\"Unexpected error: {e}\")\n        return None\n</code></pre>"},{"location":"guide/error-handling/#best-practices","title":"Best Practices","text":"<ol> <li>Always validate input: Check file existence and size before parsing</li> <li>Catch specific exceptions first: Handle <code>ValidationError</code>, <code>ParseError</code>, and <code>FileError</code> before the base <code>TeehistorianError</code></li> <li>Provide meaningful error messages: Help users understand what went wrong</li> <li>Clean up resources: Use context managers (<code>with</code> statements) for file handling</li> <li>Log errors appropriately: Consider using Python's logging module for production code</li> </ol>"},{"location":"guide/error-handling/#example-with-logging","title":"Example with Logging","text":"<pre><code>import logging\nimport teehistorian_py as th\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef parse_file(filename):\n    try:\n        with open(filename, \"rb\") as f:\n            data = f.read()\n\n        logger.info(f\"Parsing {filename} ({len(data)} bytes)\")\n        parser = th.Teehistorian(data)\n\n        chunk_count = 0\n        for chunk in parser:\n            chunk_count += 1\n\n        logger.info(f\"Successfully parsed {chunk_count} chunks\")\n\n    except th.ValidationError as e:\n        logger.error(f\"Validation error in {filename}: {e}\")\n    except th.ParseError as e:\n        logger.error(f\"Parse error in {filename}: {e}\")\n    except Exception as e:\n        logger.exception(f\"Unexpected error parsing {filename}\")\n</code></pre>"}]}